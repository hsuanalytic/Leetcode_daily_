# 1. Two Sum
[Two Sum - LeetCode](https://leetcode.com/problems/two-sum/description/)

## Problem Description
Given an array of integers `nums` and an integer `target`, return indices of the two numbers such that they add up to `target`. <br>
You may assume that each input would have exactly one solution, and you may not use the same element twice. <br>
You can return the answer in any order.

For example, <br>
```
Input: nums = [2, 7, 11, 15], target = 9
Output: [0, 1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].
```

Constraints:
1. 2 <= nums.length <= 104
2. -109 <= nums[i] <= 109
3. -109 <= target <= 109
4. Only one valid answer exists.

 
## Understanding (I/O, Constraints)
The problem requires finding two numbers in the given `nums` array that add up to the `target` value. The solution should return the **indices** of these two numbers.

The problem assumes that there is always **EXACTLY ONE** valid solution (so multiple solutions cannot exist), and the same element cannot be used twice. The order of the returned indices does not matter.

The problem also provides the range of each variable, giving a better understanding of the input constraints. The `nums` will have at least 2 elements and at most 104 elements, with each element is within the range of -109 to 109. Besides, the `target` value will also fall within the range -109 to 109.

## Approach
### 1 - Brute Force Approach
The most straightforward approach is the **brute force approach**, which use **nested For loops** to iterate over the `nums` and find the sum of each two elements. Then compare the sum with the `target` value, continuing the loops until we find the elements that add up to the `target`. Once we find a match, we return the indices as the answer.

![](https://media.giphy.com/media/v1.Y2lkPTc5MGI3NjExaDFlODl4Ymtwd3h3dWl0NjhsaHQ4MHpnN2ptbjRzdG1lamN5bzQ5MCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/cOj9t2kyRQMuynbRip/giphy.gif)

Implementing this approach is relatively simple, as shown in the following code:
```python
class Solution(object):
    def twoSum(self, nums, target) -> List[int]:
        # iterate over all elements in nums
        for i in range(len(nums)):
            # iterate over elements after the current one
            for j in range(i+1, len(nums)): 
                if nums[i]+nums[j] == target:
                    return [i, j]
        return []
```
The result beats 42.9% in Runtime and 52.5% in Memory.

### 2 - Optimized Approach (Using Hash Table/Dictionary)


## Complexity Analysis
### 1 - Brute Force Approach
- Time Complexity: O(N^2), Since we have nested loops
- Space Complexity: O(1)


### 2 - Optimized Approach (Using Hash Table/Dictionary):


## Summary

